{"version":3,"file":"bundle.umd.js","sources":["../src/util.ts","../src/node.ts","../src/parser.ts","../src/m.ts","../src/match.ts","../src/index.ts"],"sourcesContent":["import { Node } from \"./node\";\n\nconst words = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'.split('')\n\nexport const toUnicode = function (theString: string) {\n    let unicodeString = '';\n    for (let i = 0; i < theString.length; i++) {\n        let theUnicode = theString.charCodeAt(i).toString(16).toUpperCase();\n        while (theUnicode.length < 4) {\n            theUnicode = '0' + theUnicode;\n        }\n        theUnicode = '\\\\u' + theUnicode;\n        unicodeString += theUnicode;\n    }\n    return unicodeString;\n}\n\nexport const toHex = function (theString: string) {\n    let unicodeString = '';\n    for (let i = 0; i < theString.length; i++) {\n        let theUnicode = theString.charCodeAt(i).toString(16).toUpperCase();\n        while (theUnicode.length < 2) {\n            theUnicode = '0' + theUnicode;\n        }\n        theUnicode = '\\\\x' + theUnicode;\n        unicodeString += theUnicode;\n    }\n    return unicodeString;\n}\n\n\nexport const toCharCode = function (escapeString: string) {\n    if (escapeString.indexOf('\\\\') === 0 && escapeString.length > 1) {\n        return eval(`\"${escapeString}\"`).charCodeAt(0)\n    }\n    return escapeString.charCodeAt(0)\n}\n\nexport const toCode = function (escapeString: string) {\n    if (escapeString.indexOf('\\\\') === 0 && escapeString.length > 1) {\n        return eval(`\"${escapeString}\"`)\n    }\n    return escapeString\n}\n\nconst integers = '0123456789'.split('')\n\nexport const isInteger = (s: string | undefined) => {\n    if (typeof s === 'string') {\n        for (let i = 0; i < integers.length; i++) {\n            if (integers[i] === s) {\n                return true\n            }\n        }\n    }\n\n    return false;\n}\n\nexport const isWordChar = (e: number, input: string) => {\n    if (e === -1 || e === input.length) {\n        return false\n    }\n    const c = input[e]\n    return isWordChar2(c)\n}\n\nexport const isWordChar2 = (c: string) => {\n    return words.indexOf(c) > -1\n}\n\n\nconst f = '\\u000C', n = '\\u000A', r = '\\u000D', t = '\\u0009', v = '\\u000B', o = '\\u0000', d = '0123456789';\nconst s = f + n + r + t + v + '\\u0020\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff'\n\nexport const SPECIAL_CODES: { [k: string]: string } = {\n    '\\\\f': f,\n    '\\\\n': n,\n    '\\\\r': r,\n    '\\\\t': t,\n    '\\\\v': v,\n    '\\\\0': o\n}\n\nexport const isSpace = (code: string) => {\n    return s.indexOf(code) > -1;\n}\n\nconst LineTerminator = ['\\u000A', '\\u000D', '\\u2028', '\\u2029']\n\nexport const isLineTerminator = (code: string) => {\n    return LineTerminator.indexOf(code) > -1;\n}\n\nexport const evaluateQuantifierValue = (node: Node) => {\n    const greedy = node.greedy;\n    const value = node.value || '';\n    let min = 0;\n    let max = 0;\n    if (value === '*') {\n        max = Infinity\n        return {\n            min,\n            max,\n            greedy\n        }\n    }\n    if (value === '+') {\n        min = 1\n        max = Infinity\n        return {\n            min,\n            max,\n            greedy\n        }\n    }\n    if (value === '?') {\n        min = 0\n        max = 1\n        return {\n            min,\n            max,\n            greedy\n        }\n    }\n    const input = value.split(',')\n    min = +input[0]\n    max = input[1] ? +input[1] : Infinity\n    return {\n        min,\n        max,\n        greedy\n    }\n}\n\nexport const getParenCountByAtom = (node: Node): number => {\n    if (node.children.length) {\n        return +(node.type === 'SubExpression' && Number.isFinite(node.groupIndex)) + node.children.reduce((accumulator, item) => {\n            return getParenCountByAtom(item) + accumulator\n        }, 0)\n    }\n    return +(node.type === 'SubExpression' && Number.isFinite(node.groupIndex))\n}\n\nexport const getParenIndexByNode = (node: Node, nodes: Node[], index = 0): number => {\n    const getIndex = (nodes: Node[]) => {\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const n = nodes[i]\n            if (Number.isFinite(n.groupIndex) && typeof n.groupIndex !== 'undefined') {\n                index++\n            }\n            if (node === n) {\n                return true\n            }\n            if (n.children.length) {\n                if (getIndex(n.children)) {\n                    return true\n                }\n            }\n        }\n        return false\n    }\n    getIndex(nodes)\n    return index\n}\n\nexport const canonicalize = (ch: string, ignoreCase = false) => {\n    if (!ignoreCase) {\n        return ch\n    }\n    const u = ch.toUpperCase();\n    if (u.length !== 1) {\n        return ch\n    }\n    const cu = u\n    if (ch.charCodeAt(0) >= 128 && cu.charCodeAt(0) < 128) {\n        return ch\n    }\n    return cu\n}\n","export class Node {\n    type = ''\n    children: Node[] = []\n    value?: string\n    closed?: boolean\n    parent?: Node\n    greedy?: boolean = true\n    groupIndex?: number\n    constructor(type: string, value: string) {\n        this.type = type\n        this.value = value\n    }\n}\n\nexport class NodeProcesser {\n    startNode(type = '', value = '') {\n        return new Node(type, value)\n    }\n    closeNode(node: Node) {\n        node.closed = true\n    }\n    finishNode(node: Node, type: string) {\n        node.type = type\n    }\n}","import { isInteger } from './util'\nimport { Node, NodeProcesser } from './node'\n\nclass TokenType {\n    label = ''\n    conf = {}\n    constructor(label: string, conf = {}) {\n        this.label = label\n        this.conf = conf\n    }\n}\n\nconst letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('')\n\nconst HexDigits = '0123456789ABCDEFabcdef'.split('')\n\nconst types = {\n    backslash: new TokenType('\\\\'),\n    start: new TokenType('^'),\n    end: new TokenType('$'),\n    or: new TokenType('|'),\n    anti: new TokenType('^'),\n    oneMore: new TokenType('*'),\n    add: new TokenType('+'),\n    question: new TokenType('?'),\n    dot: new TokenType('.'),\n    parenL: new TokenType('('),\n    parenR: new TokenType(\")\"),\n    bracketL: new TokenType('['),\n    bracketR: new TokenType(\"]\"),\n    bracesL: new TokenType('{'),\n    bracesR: new TokenType('}'),\n    backspace: new TokenType('[\\\\b]'),\n    range: new TokenType('-'),\n    groupIs: new TokenType('?='),\n    groupElse: new TokenType('?!'),\n    groupAtom: new TokenType('?:'),\n    controlLetter: new TokenType('\\\\c'),\n    hexadecimal: new TokenType('\\\\x'),\n    unicode: new TokenType('\\\\u'),\n    controllerEscape: [\n        new TokenType('\\\\f'),\n        new TokenType('\\\\n'),\n        new TokenType('\\\\r'),\n        new TokenType('\\\\t'),\n        new TokenType('\\\\v'),\n    ],\n    characterClassEscape: [\n        new TokenType('\\\\d'),\n        new TokenType('\\\\D'),\n        new TokenType('\\\\s'),\n        new TokenType('\\\\S'),\n        new TokenType('\\\\w'),\n        new TokenType('\\\\W'),\n    ],\n    assertionEscape: [\n        new TokenType('\\\\b'),\n        new TokenType('\\\\B')\n    ],\n    kws: [\n        new TokenType('\\\\0')\n    ]\n}\n\nconst keyCodes = '\\\\^$|*+?.{['\n\nexport class Parser extends NodeProcesser {\n    input = ''\n    loc = 0\n    pos = 0\n    end = 0\n    groups: Node[] = []\n    node: Node = this.startNode('RegularExpressions')\n    groupCount = 0\n    constructor(str: string) {\n        super()\n        this.input = str\n        this.end = str.length\n        this.parse()\n    }\n    isRangeNode(node: Node) {\n        if (node.type === 'CharacterClassEscape' || node.type === 'CharacterRange' || node.type === 'assertionEscape' || node.type === 'CharacterClassAnti') {\n            return true\n        }\n        return false\n    }\n    parse() {\n        this.pos = 0\n        this.parseStart()\n    }\n    parseStart() {\n        const node = this.node\n        while (this.end > this.pos) {\n            this.next(node);\n        }\n    }\n    parseWord(w: string, node: Node) {\n        switch (w) {\n            case types.start.label:\n                node.children.push(this.startNode('Assertion', w));\n                this.next(node);\n                break;\n            case types.backslash.label:\n                this.processBackSlash(node);\n                this.next(node);\n                break;\n            case types.question.label:\n                if (this.processGreedy(node)) {\n                    break;\n                }\n            case types.add.label:\n            case types.oneMore.label:\n                const nn = this.startNode('QuantifierPrefix', w)\n                this.addQuantifierPrefixNode(node, nn)\n                this.next(node);\n                break;\n            case types.dot.label:\n                node.children.push(this.startNode('Atom', w))\n                this.next(node);\n                break;\n            case types.parenL.label:\n                this.processParenL(node);\n                break;\n            case types.parenR.label:\n                const lastg = this.groups[this.groups.length - 1];\n                if (lastg && !lastg.closed) {\n                    lastg.closed = true\n                    this.groups.splice(-1, 1)\n                    if (lastg.parent) {\n                        this.next(lastg.parent)\n                    }\n                } else {\n                    this.raise(`Unmatched ')'`)\n                }\n                break;\n            case types.bracesL.label:\n                this.processBracesL(node);\n                break;\n            case types.bracesR.label:\n                this.processBracesR(node);\n                break;\n            case types.bracketL.label:\n                this.processBracket(node)\n                break;\n            case types.end.label:\n                node.children.push(this.startNode('Assertion', w))\n                this.next(node);\n                break;\n            case types.or.label:\n                this.processOr(node);\n                break;\n            default:\n                node.children.push(this.startNode('PatternCharacter', w))\n                this.next(node);\n                break;\n        }\n    }\n    // ?\n    processGreedy(node: Node) {\n        const last = node.children[node.children.length - 1]\n        if (last) {\n            if (last.type === 'QuantifierPrefix') {\n                if (last.greedy) {\n                    last.greedy = false\n                    return true\n                } else {\n                    this.raise('Nothing to repeat')\n                }\n            }\n        }\n    }\n    // \\\n    processBackSlash(node: Node, inBracket = false) {\n        while (true) {\n            const w = this.readWord();\n            if (!w) {\n                return\n            }\n            if (w[1] === '\\\\') {\n                node.children.push(this.startNode('PatternCharacter', w[1]))\n                break;\n            }\n            if (w[1] === '^') {\n                node.children.push(this.startNode('PatternCharacter', w[1]))\n                break;\n            }\n            if (keyCodes.indexOf(w[1]) > -1) {\n                if (inBracket) {\n                    node.children.push(this.startNode('PatternCharacter', '\\\\'))\n                }\n                node.children.push(this.startNode('PatternCharacter', w[1]))\n                break\n            }\n            if (this.processEscape(node, w)) {\n                break;\n            }\n            if (!isInteger(w.slice(-1))) {\n                const value = w.substr(1, w.length - 2)\n                if (isInteger(value)) {\n                    node.children.push(this.startNode('DecimalEscape', value))\n                } else {\n                    node.children.push(this.startNode('PatternCharacter', w.substr(1)))\n                }\n                this.pos--;\n                break;\n            }\n            if (this.pos >= this.end) {\n                const value = w.substr(1)\n                if (isInteger(value)) {\n                    node.children.push(this.startNode('DecimalEscape', value))\n                } else {\n                    node.children.push(this.startNode('PatternCharacter', w.substr(1)))\n                }\n                return;\n            }\n        }\n    }\n    // \\\n    processEscape(node: Node, w: string) {\n        // TODO\n        if (w === types.controlLetter.label) {\n            const n = this.startNode('ControlLetter')\n            node.children.push(n)\n            if (this.end <= this.pos) {\n                this.raise('\\\\ at end of pattern')\n                return;\n            }\n            const word = this.eatWord()\n            if (letters.includes(word)) {\n                n.value = word\n            } else {\n                this.parseWord(word, node)\n            }\n            return true\n        }\n        if (w === types.hexadecimal.label) {\n            const n = this.startNode('HexEscapeSequence')\n            node.children.push(n)\n            const word = [this.eatWord(), this.eatWord()];\n            if (HexDigits.includes(word[0]) && HexDigits.includes(word[1])) {\n                n.value = word.join('')\n                return true\n            }\n            this.pos -= 2\n            this.loc = this.pos\n            return true\n        }\n        if (w === types.unicode.label) {\n            const n = this.startNode('UnicodeEscapeSequence')\n            node.children.push(n)\n            const word = [this.eatWord(), this.eatWord(), this.eatWord(), this.eatWord()];\n            if (HexDigits.includes(word[0]) && HexDigits.includes(word[1]) && HexDigits.includes(word[2]) && HexDigits.includes(word[3])) {\n                n.value = w + word.join('')\n                return true\n            }\n            this.pos -= 4\n            this.loc = this.pos\n            return true\n        }\n        const each = (list: TokenType[], type: string) => {\n            for (let i = 0, len = list.length; i < len; i++) {\n                const kws = list[i];\n                if (kws.label === w) {\n                    node.children.push(this.startNode(type, w));\n                    return true\n                }\n            }\n            return false\n        }\n        return each(types.kws, 'CharacterKey') || each(types.controllerEscape, 'ControllerEscape') || each(types.characterClassEscape, 'CharacterClassEscape') || each(types.assertionEscape, 'AssertionEscape')\n    }\n    // [\n    processBracket(node: Node) {\n        const w = this.input.slice(this.loc, this.loc + 4);\n        if (w === types.backspace.label) {\n            const nn = this.startNode('ClassEscape', types.backspace.label)\n            node.children.push(nn)\n            this.loc = this.loc + 4\n            this.pos = this.loc\n            this.next(node)\n            return\n        }\n        const nn = this.startNode('CharacterClass')\n        while (true) {\n            if (this.end <= this.pos) {\n                this.raise('missing /')\n                return;\n            }\n            const word = this.eatWord();\n            if (word === types.bracketR.label) {\n                nn.closed = true;\n                break\n            }\n            switch (word) {\n                case types.anti.label:\n                    if (nn.children.length === 0) {\n                        nn.children.push(this.startNode('CharacterClassAnti'))\n                    } else {\n                        nn.children.push(this.startNode('SourceCharacter', word))\n                    }\n                    break;\n                case types.bracketL.label:\n                    this.raise('missing /')\n                    return;\n                case types.backslash.label:\n                    this.processBackSlash(nn, true);\n                    break;\n                case types.range.label:\n                    const lastChild = nn.children[nn.children.length - 1]\n                    if (!lastChild || this.isRangeNode(lastChild)) {\n                        nn.children.push(this.startNode('SourceCharacter', word))\n                    } else {\n                        const range = this.startNode('CharacterRange', word)\n                        range.children.push(lastChild)\n                        if (this.processRange(range)) {\n                            return;\n                        }\n                        if (range.closed) {\n                            nn.children[nn.children.length - 1] = range\n                        } else {\n                            range.value = types.range.label\n                            const children = range.children\n                            range.children = []\n                            nn.children.push(range, ...children.slice(1))\n                        }\n                    }\n                    break;\n                default:\n                    nn.children.push(this.startNode('SourceCharacter', word))\n                    break;\n            }\n        }\n        node.children.push(nn)\n        this.next(node)\n    }\n\n    processRange(node: Node) {\n        if (this.end <= this.pos) {\n            this.raise('missing /')\n            return;\n        }\n        const word = this.eatWord();\n        switch (word) {\n            case types.bracketR.label:\n                this.finishNode(node, 'SourceCharacter')\n                return;\n            case types.bracketL.label:\n                this.raise('Range out of order in character class')\n                return true;\n            case types.backslash.label:\n                this.processBackSlash(node, true);\n                if (this.isRangeNode(node.children[node.children.length - 1])) {\n                    this.finishNode(node, 'SourceCharacter')\n                    return;\n                }\n                node.closed = true\n                return;\n            case types.range.label:\n                const lastChild = node.children[node.children.length - 1]\n                if (lastChild && lastChild.type === 'CharacterRange' && !lastChild.closed) {\n                    this.raise('Range out of order in character class')\n                    return true;\n                }\n                return;\n            default:\n                node.closed = true\n                node.children.push(this.startNode('SourceCharacter', word))\n                return\n        }\n    }\n    // |\n    processOr(node: Node) {\n        const an = this.startNode('AlternationExpression', types.or.label)\n        const cn1 = this.startNode('ConcatenationExpression')\n        const children = node.children\n        cn1.children = children\n        const cn2 = this.startNode('ConcatenationExpression')\n        an.children.push(cn1, cn2)\n        node.children = [an]\n        this.next(cn2)\n    }\n    raise(e: string) {\n        throw new SyntaxError(e)\n    }\n    // (\n    processParenL(node: Node) {\n        const subNode = this.startNode('SubExpression')\n        this.groups.push(subNode);\n        node.children.push(subNode)\n        if (this.end <= this.pos) {\n            this.raise('Unterminated group')\n            return\n        }\n        subNode.parent = node\n        const w = this.eatWord() + this.eatWord();\n        if (w === types.groupIs.label) {\n            subNode.value = types.groupIs.label\n            this.next(subNode);\n            return\n        }\n        if (w === types.groupElse.label) {\n            subNode.value = types.groupElse.label\n            this.next(subNode);\n            return\n        }\n        if (w === types.groupAtom.label) {\n            subNode.value = types.groupAtom.label\n            this.next(subNode);\n            return;\n        }\n        subNode.groupIndex = this.groupCount\n        this.groupCount = subNode.groupIndex + 1\n        this.pos -= 2\n        this.loc = this.pos;\n        while (!subNode.closed) {\n            if (this.end > this.pos) {\n                this.next(subNode);\n            } else {\n                this.raise('Unterminated group')\n            }\n        }\n    }\n    addQuantifierPrefixNode(node: Node, q: Node) {\n        const last = node.children[node.children.length - 1]\n        if (last) {\n            if (last.type === 'QuantifierPrefix') {\n                this.raise('Nothing to repeat')\n                return\n            }\n            q.children.push(last)\n            node.children[node.children.length - 1] = q\n        } else {\n            if (node.type === 'SubExpression') {\n                this.raise('Invalid group')\n            } else {\n                this.raise('Nothing to repeat')\n            }\n        }\n    }\n    // {\n    processBracesL(node: Node) {\n        const nn = this.startNode('QuantifierPrefix', '{')\n        while (this.end > this.pos && nn.type === 'QuantifierPrefix' && !nn.closed) {\n            this.next(nn)\n        }\n        if (nn.type !== 'QuantifierPrefix' || !nn.closed) {\n            this.finishNode(nn, 'PatternCharacter')\n            nn.value = '{'\n            const children = nn.children\n            nn.children = []\n            node.children.push(nn, ...children)\n        } else {\n            this.addQuantifierPrefixNode(node, nn)\n        }\n        this.next(node)\n    }\n    // }\n    processBracesR(node: Node) {\n        if (node.type === 'QuantifierPrefix') {\n            const hasComma = false\n            let value = ''\n            for (let i = 0, len = node.children.length; i < len; i++) {\n                const item = node.children[i]\n                if (i === 0) {\n                    if (item.type === 'PatternCharacter' && isInteger(item.value)) {\n                        value += item.value;\n                    } else {\n                        this.finishNode(node, 'PatternCharacter')\n                        return;\n                    }\n                } else {\n                    if (!hasComma) {\n                        if (item.type === 'PatternCharacter' && item.value === ',') {\n                            value += item.value;\n                            continue\n                        }\n                        if (item.type === 'PatternCharacter' && isInteger(item.value)) {\n                            value += item.value;\n                            continue\n                        } else {\n                            this.finishNode(node, 'PatternCharacter')\n                            return;\n                        }\n                    }\n                    if (item.type === 'PatternCharacter' && isInteger(item.value)) {\n                        value += item.value;\n                    } else {\n                        this.finishNode(node, 'PatternCharacter')\n                        return;\n                    }\n                }\n            }\n            node.children = []\n            node.closed = true\n            node.value = value\n        } else {\n            node.children.push(this.startNode('PatternCharacter', '}'))\n            this.next(node)\n        }\n    }\n    next(node: Node) {\n        const w = this.eatWord()\n        if (w) {\n            this.parseWord(w, node)\n        }\n    }\n    eatWord() {\n        this.loc = this.pos\n        return this.readWord()\n    }\n    readWord() {\n        this.pos++\n        return this.input.slice(this.loc, this.pos)\n    }\n}\n","import { Node } from './node';\nimport { canonicalize } from './util'\n\nexport interface State {\n    endIndex: number\n    captures: (string | undefined)[]\n    input: string\n    option: {\n        ignoreCase?: boolean\n        multiline?: boolean\n        nodes: Node[]\n    }\n}\n\nexport type Matcher = (x: State, m?: Next) => State | null\n\nexport type Next = (x: State) => State | null\n\nexport const continuation = (x: State) => x\n\nexport const baseMatcher = (m: (x: string) => boolean, anti = false) => {\n    return (state: State, next: Next) => {\n        const { endIndex, input } = state;\n        const code = canonicalize(input[endIndex + 1], state.option.ignoreCase)\n        const i = m(code);\n        const isTrue = anti ? !i : i\n        if (!isTrue) {\n            return null\n        }\n        state.endIndex = endIndex + 1\n        return next(state)\n    }\n}\n\nexport const combineOrMatchers = (nodes: Node[], ctr: (node: Node) => any, anti?: boolean) => {\n    const matchers = nodes.map(ctr)\n    return function (state: State, next: Next = continuation) {\n        const { endIndex } = state\n        if (endIndex >= state.input.length - 1) {\n            return null\n        }\n        for (let i = 0; i < matchers.length; i++) {\n            state.endIndex = endIndex\n            const m = matchers[i]\n            if (anti) {\n                const r = m(state, continuation)\n                if (r) {\n                    return null\n                }\n            } else {\n                const r = m(state, next)\n                if (r) {\n                    return r\n                }\n            }\n        }\n        if (anti) {\n            state.endIndex = endIndex + 1\n            return next(state)\n        }\n        return null\n    }\n}\n\nexport const combineSerialMatchers = (nodes: Node[], ctr: (node: Node) => any, c: Next = continuation) => {\n    const ns = nodes.slice().reverse();\n    let matcher = c\n    for (let i = 0; i < ns.length; i++) {\n        const m = ctr(ns[i])\n        if (i === 0) {\n            matcher = function (x) {\n                return m(x, c)\n            }\n            continue\n        }\n        const n = matcher\n        matcher = function (x) {\n            return m(x, n)\n        }\n    }\n    return function (x: State, next?: Next) {\n        c = next ? next : c\n        return matcher(x)\n    }\n}\n\nexport const characterSetMatcher = (s: string, invert = false) => {\n    return function (state: State, next: Next) {\n        const { endIndex } = state\n        if (endIndex === state.input.length - 1) {\n            return null\n        }\n        const ch = state.input[endIndex + 1]\n        const cc = canonicalize(ch, state.option.ignoreCase)\n        if (invert === false) {\n            if (canonicalize(s, state.option.ignoreCase) !== cc) {\n                return null\n            }\n        } else {\n            if (canonicalize(s, state.option.ignoreCase) === cc) {\n                return null\n            }\n        }\n        const cap = state.captures\n        const y = { ...state, endIndex: endIndex + 1, captures: cap }\n        return next(y)\n    }\n}\n\nexport const repeatMatcher = (m: Matcher, min: number, max: number, greedy: boolean, x: State, c: Next, parenIndex: number, parenCount: number) => {\n    if (max === 0) {\n        return c(x)\n    }\n    const d: Next = function (y: State) {\n        if (min === 0 && y.endIndex === x.endIndex) {\n            return null\n        }\n        const min2 = min === 0 ? 0 : min - 1;\n        const max2 = max === Infinity ? Infinity : max - 1\n        return repeatMatcher(m, min2, max2, greedy, y, c, parenIndex, parenCount)\n    }\n    const cap = [...x.captures]\n    for (let k = parenIndex + 1; k <= parenIndex + parenCount; k++) {\n        cap[k] = undefined\n    }\n    const e = x.endIndex\n    const xr = {\n        ...x,\n        endIndex: e,\n        captures: cap\n    }\n    if (min !== 0) {\n        return m(xr, d)\n    }\n    if (greedy === false) {\n        const z = c(x)\n        if (z) {\n            return z\n        }\n        return m(xr, d)\n    }\n    const z = m(xr, d)\n    if (z) {\n        return z\n    }\n    return c(x)\n}\n","import {\n    isWordChar,\n    isWordChar2, toCharCode, isInteger, isSpace, SPECIAL_CODES, isLineTerminator, evaluateQuantifierValue,\n    getParenCountByAtom,\n    canonicalize,\n    toCode,\n    getParenIndexByNode\n} from './util'\nimport { Node } from './node'\nimport {\n    baseMatcher,\n    combineOrMatchers,\n    combineSerialMatchers,\n    characterSetMatcher,\n    repeatMatcher,\n    State,\n    Next,\n    continuation\n} from './m'\n\nconst beginningMatcher = () => {\n    return function (state: State, next: Next) {\n        const { endIndex } = state;\n        if ((endIndex + 1) !== 0) {\n            if (state.option.multiline) {\n                if (isLineTerminator(state.input[endIndex])) {\n                    return next(state)\n                }\n            }\n            return null\n        }\n        return next(state)\n    }\n}\n\nconst endMatcher = () => {\n    return function (state: State, next: Next) {\n        const { endIndex, input } = state;\n        if (endIndex !== input.length - 1) {\n            if (state.option.multiline) {\n                if (isLineTerminator(state.input[endIndex + 1])) {\n                    return state\n                }\n            }\n            return null\n        }\n        return state\n    }\n}\n\nconst getRangeMatcher = (nodes: Node[]) => {\n    return function (state: State, next: Next) {\n        const { endIndex } = state;\n        const code = canonicalize(state.input[endIndex + 1], state.option.ignoreCase).charCodeAt(0);\n        const [start, end] = nodes;\n        let startValue = start.value || '';\n        let endValue = end.value || '';\n        if (start.type === 'ControllerEscape' || start.type === 'CharacterKey') {\n            startValue = canonicalize(SPECIAL_CODES[startValue], state.option.ignoreCase)\n        }\n        const s = toCharCode(startValue)\n        if (end.type === 'ControllerEscape' || end.type === 'CharacterKey') {\n            endValue = canonicalize(SPECIAL_CODES[endValue], state.option.ignoreCase)\n        }\n        const e = toCharCode(endValue)\n        const result = s <= code && e >= code\n        if (!result) {\n            return null\n        }\n        state.endIndex = endIndex + 1\n        return next(state)\n    }\n}\n\nconst getCharacterClassEscapeMatcher = (pattern: string) => {\n    if (pattern === '\\\\d') {\n        return baseMatcher(isInteger)\n    }\n    if (pattern === '\\\\D') {\n        return baseMatcher(isInteger, true)\n    }\n    if (pattern === '\\\\s') {\n        return baseMatcher(isSpace)\n    }\n    if (pattern === '\\\\S') {\n        return baseMatcher(isSpace, true)\n    }\n    if (pattern === '\\\\w') {\n        return baseMatcher(isWordChar2)\n    }\n    if (pattern === '\\\\W') {\n        return baseMatcher(isWordChar2, true)\n    }\n}\n\nconst getWordCharMatch = (anti = false) => {\n    return function (state: State, next: Next) {\n        const { endIndex: e, input } = state\n        const a = +isWordChar(e, input)\n        const b = +isWordChar(e + 1, input);\n        let result = !!(a ^ b)\n        if (anti) {\n            result = !result\n        }\n        if (!result) {\n            return null\n        }\n        return next(state)\n    }\n}\n\nconst getDecimalEscapeMatcher = (node: Node) => {\n    let value = 0\n    if (node.value) {\n        value = +node.value\n    }\n    return function (state: State, next: Next) {\n        const { endIndex } = state\n        const cap = state.captures[value]\n        if (typeof cap !== 'string') {\n            return next(state)\n        }\n        const s = state.input.slice(endIndex + 1, cap.length + endIndex + 1)\n        if (cap.length !== s.length) {\n            return null\n        }\n        for (let i = 0; i < cap.length; i++) {\n            if (canonicalize(cap[i], state.option.ignoreCase) !== canonicalize(s[i], state.option.ignoreCase)) {\n                return null\n            }\n        }\n        state.endIndex = endIndex + cap.length\n        return next(state)\n    }\n}\n\nconst getCharacterClassMatcher = (node: Node) => {\n    let isAnti = false\n    let children = []\n    if (node.children[0].type === 'CharacterClassAnti') {\n        isAnti = true\n        children = node.children.slice(1)\n    } else {\n        children = node.children\n    }\n    return combineOrMatchers(children, getBaseMatcher, isAnti)\n}\n\n// |\nconst getAlternationExpressionMatcher = (node: Node) => {\n    const m1 = combineSerialMatchers(node.children[0].children, getBaseMatcher)\n    const m2 = combineSerialMatchers(node.children[1].children, getBaseMatcher)\n    return function (state: State, next: Next) {\n        return m1(state, next) || m2(state, next)\n    }\n}\n\n// ()\nconst getSubExpressionMatcher = (node: Node) => {\n    const m = combineSerialMatchers(node.children, getBaseMatcher);\n    if (node.value === '?=') {\n        return function (state: State, next: Next) {\n            const { endIndex } = state\n            const r = m(state)\n            if (!r) {\n                return r\n            }\n            const cap = r.captures\n            const xe = endIndex\n            const z = { ...state, endIndex: xe, captures: cap }\n            return next(z)\n        }\n    }\n    if (node.value === '?!') {\n        return function (state: State, next: Next) {\n            const x = { ...state }\n            const r = m(state, continuation)\n            if (r) {\n                return null\n            }\n            return next(x)\n        }\n    }\n    if (node.value === '?:') {\n        return m\n    }\n    return function (state: State, next: Next) {\n        const xe = state.endIndex;\n        const d = function (y: State) {\n            const cap = [...y.captures];\n            const ye = y.endIndex;\n            const s = state.input.slice(xe + 1, ye + 1)\n            cap[(node.groupIndex || 0) + 1] = s;\n            const z = {\n                ...state,\n                endIndex: ye,\n                captures: cap\n            }\n            return next(z)\n        }\n        return m(state, d)\n    }\n}\n\nconst getQuantifierPrefixMatcher = (node: Node) => {\n    const m = getBaseMatcher(node.children[0])\n    const { min, max, greedy } = evaluateQuantifierValue(node);\n    if (max < min) {\n        throw new SyntaxError('')\n    }\n    const parenCount = getParenCountByAtom(node)\n    return function (state: State, next: Next) {\n        const parenIndex = getParenIndexByNode(node, state.option.nodes)\n        return repeatMatcher(m, min, max, !!greedy, state, next, parenIndex, parenCount)\n    }\n}\n\nconst getClassEscapeMatcher = (node: Node) => {\n    if (node.value === '[\\\\b]') {\n        return characterSetMatcher('\\u0008')\n    }\n}\n\nconst getCharacterKeyMatcher = (node: Node) => {\n    if (node.value === '\\\\0') {\n        return characterSetMatcher(canonicalize(SPECIAL_CODES[node.value]))\n    }\n}\n\n\nconst getBaseMatcher = (node: Node): any => {\n    if (node.type === 'PatternCharacter' || node.type === 'SourceCharacter') {\n        return characterSetMatcher(node.value || '')\n    }\n    if (node.type === 'Atom' && node.value === '.') {\n        return characterSetMatcher(SPECIAL_CODES['\\\\n'], true)\n    }\n    if (node.type === 'Assertion') {\n        if (node.value == '^') {\n            return beginningMatcher()\n        }\n        return endMatcher()\n    }\n    if (node.type === 'HexEscapeSequence') {\n        return characterSetMatcher(toCode(node.value || ''))\n    }\n    if (node.type === 'UnicodeEscapeSequence') {\n        return characterSetMatcher(toCode(node.value || ''))\n    }\n    if (node.type === 'CharacterRange') {\n        return getRangeMatcher(node.children)\n    }\n    if (node.type === 'ControllerEscape') {\n        return characterSetMatcher(SPECIAL_CODES[node.value || ''])\n    }\n    if (node.type === 'CharacterClassEscape') {\n        return getCharacterClassEscapeMatcher(node.value || '')\n    }\n    if (node.type === 'AssertionEscape') {\n        return getWordCharMatch(node.value === '\\\\B')\n    }\n    if (node.type === 'CharacterClass') {\n        return getCharacterClassMatcher(node)\n    }\n    if (node.type === 'AlternationExpression') {\n        return getAlternationExpressionMatcher(node)\n    }\n    if (node.type === 'SubExpression') {\n        return getSubExpressionMatcher(node)\n    }\n    if (node.type === 'QuantifierPrefix') {\n        return getQuantifierPrefixMatcher(node)\n    }\n    if (node.type === 'DecimalEscape') {\n        return getDecimalEscapeMatcher(node)\n    }\n    if (node.type === 'ClassEscape') {\n        return getClassEscapeMatcher(node)\n    }\n    if (node.type === 'CharacterKey') {\n        return getCharacterKeyMatcher(node)\n    }\n}\n\nexport const getMatcher = (node: Node, option: { [k: string]: any } = {}) => {\n    const m = combineSerialMatchers(node.children, getBaseMatcher)\n    return function (input: string, i: number) {\n        return m({ endIndex: i - 1, input, captures: [], option: { ...option, nodes: node.children } })\n    }\n}\n","import { Parser } from './parser';\nimport { getMatcher } from './match';\nimport { State } from './m'\n\nexport default class RegExp2 {\n    source = ''\n    global = false\n    ignoreCase = false\n    multiline = false\n    lastIndex = 0\n    private matcher: (s: string, i: number) => State | null\n    constructor(reg: string, flag?: string) {\n        this.source = reg\n        if (flag) {\n            this.global = flag.indexOf('g') > -1\n            this.ignoreCase = flag.indexOf('i') > -1\n            this.multiline = flag.indexOf('m') > -1\n        }\n        const parse = new Parser(reg)\n        this.matcher = getMatcher(parse.node, {\n            global: this.global,\n            ignoreCase: this.ignoreCase,\n            multiline: this.multiline,\n        })\n    }\n    exec(s: string) {\n        const len = s.length\n        let i = this.lastIndex\n        if (this.global === false) {\n            i = 0\n        }\n        let matchSucceeded = false\n        let r: State | null = null\n        while (matchSucceeded === false) {\n            if (i < 0 || i > len) {\n                this.lastIndex = 0\n                return null\n            }\n            r = this.matcher(s, i)\n            if (r) {\n                matchSucceeded = true\n            } else {\n                i = i + 1\n            }\n        }\n        if (!r) {\n            return null\n        }\n        const e = r.endIndex\n        if (this.global) {\n            this.lastIndex = e\n        }\n        const n = r.captures.length\n        const a: any = []\n        const matchIndex = i\n        a.index = matchIndex\n        a.input = s;\n        a.length = n\n        const matchedSubstr = s.slice(i, e + 1)\n        a[0] = matchedSubstr\n        for (let j = 1; j < n; j++) {\n            a[j] = r.captures[j]\n        }\n        return a\n    }\n}"],"names":[],"mappings":"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"}