{"version":3,"file":"bundle.cjs.js","sources":["../src/util.ts","../src/node.ts","../src/parser.ts","../src/m.ts","../src/match.ts","../src/index.ts"],"sourcesContent":["import { Node } from \"./node\";\n\nconst words = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'.split('')\n\nexport const toUnicode = function (theString: string) {\n    let unicodeString = '';\n    for (let i = 0; i < theString.length; i++) {\n        let theUnicode = theString.charCodeAt(i).toString(16).toUpperCase();\n        while (theUnicode.length < 4) {\n            theUnicode = '0' + theUnicode;\n        }\n        theUnicode = '\\\\u' + theUnicode;\n        unicodeString += theUnicode;\n    }\n    return unicodeString;\n}\n\nexport const toHex = function (theString: string) {\n    let unicodeString = '';\n    for (let i = 0; i < theString.length; i++) {\n        let theUnicode = theString.charCodeAt(i).toString(16).toUpperCase();\n        while (theUnicode.length < 2) {\n            theUnicode = '0' + theUnicode;\n        }\n        theUnicode = '\\\\x' + theUnicode;\n        unicodeString += theUnicode;\n    }\n    return unicodeString;\n}\n\n\nexport const toCharCode = function (escapeString: string) {\n    if (escapeString.indexOf('\\\\') === 0 && escapeString.length > 1) {\n        return eval(`\"${escapeString}\"`).charCodeAt(0)\n    }\n    return escapeString.charCodeAt(0)\n}\n\nexport const toCode = function (escapeString: string) {\n    if (escapeString.indexOf('\\\\') === 0 && escapeString.length > 1) {\n        return eval(`\"${escapeString}\"`)\n    }\n    return escapeString\n}\n\nconst integers = '0123456789'.split('')\n\nexport const isInteger = (s: string | undefined) => {\n    if (typeof s === 'string') {\n        for (let i = 0; i < integers.length; i++) {\n            if (integers[i] === s) {\n                return true\n            }\n        }\n    }\n\n    return false;\n}\n\nexport const isWordChar = (e: number, input: string) => {\n    if (e === -1 || e === input.length) {\n        return false\n    }\n    const c = input[e]\n    return isWordChar2(c)\n}\n\nexport const isWordChar2 = (c: string) => {\n    return words.indexOf(c) > -1\n}\n\n\nconst f = '\\u000C', n = '\\u000A', r = '\\u000D', t = '\\u0009', v = '\\u000B', o = '\\u0000', d = '0123456789';\nconst s = f + n + r + t + v + '\\u0020\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff'\n\nexport const SPECIAL_CODES: { [k: string]: string } = {\n    '\\\\f': f,\n    '\\\\n': n,\n    '\\\\r': r,\n    '\\\\t': t,\n    '\\\\v': v,\n    '\\\\0': o\n}\n\nexport const isSpace = (code: string) => {\n    return s.indexOf(code) > -1;\n}\n\nconst LineTerminator = ['\\u000A', '\\u000D', '\\u2028', '\\u2029']\n\nexport const isLineTerminator = (code: string) => {\n    return LineTerminator.indexOf(code) > -1;\n}\n\nexport const evaluateQuantifierValue = (node: Node) => {\n    const greedy = node.greedy;\n    const value = node.value || '';\n    let min = 0;\n    let max = 0;\n    if (value === '*') {\n        max = Infinity\n        return {\n            min,\n            max,\n            greedy\n        }\n    }\n    if (value === '+') {\n        min = 1\n        max = Infinity\n        return {\n            min,\n            max,\n            greedy\n        }\n    }\n    if (value === '?') {\n        min = 0\n        max = 1\n        return {\n            min,\n            max,\n            greedy\n        }\n    }\n    const input = value.split(',')\n    min = +input[0]\n    max = input[1] ? +input[1] : Infinity\n    return {\n        min,\n        max,\n        greedy\n    }\n}\n\nexport const getParenCountByAtom = (node: Node): number => {\n    if (node.children.length) {\n        return +(node.type === 'SubExpression' && Number.isFinite(node.groupIndex)) + node.children.reduce((accumulator, item) => {\n            return getParenCountByAtom(item) + accumulator\n        }, 0)\n    }\n    return +(node.type === 'SubExpression' && Number.isFinite(node.groupIndex))\n}\n\nexport const getParenIndexByNode = (node: Node, nodes: Node[], index = 0): number => {\n    const getIndex = (nodes: Node[]) => {\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const n = nodes[i]\n            if (Number.isFinite(n.groupIndex) && typeof n.groupIndex !== 'undefined') {\n                index++\n            }\n            if (node === n) {\n                return true\n            }\n            if (n.children.length) {\n                if (getIndex(n.children)) {\n                    return true\n                }\n            }\n        }\n        return false\n    }\n    getIndex(nodes)\n    return index\n}\n\nexport const canonicalize = (ch: string, ignoreCase = false) => {\n    if (!ignoreCase) {\n        return ch\n    }\n    const u = ch.toUpperCase();\n    if (u.length !== 1) {\n        return ch\n    }\n    const cu = u\n    if (ch.charCodeAt(0) >= 128 && cu.charCodeAt(0) < 128) {\n        return ch\n    }\n    return cu\n}\n","export class Node {\n    type = ''\n    children: Node[] = []\n    value?: string\n    closed?: boolean\n    parent?: Node\n    greedy?: boolean = true\n    groupIndex?: number\n    constructor(type: string, value: string) {\n        this.type = type\n        this.value = value\n    }\n}\n\nexport class NodeProcesser {\n    startNode(type = '', value = '') {\n        return new Node(type, value)\n    }\n    closeNode(node: Node) {\n        node.closed = true\n    }\n    finishNode(node: Node, type: string) {\n        node.type = type\n    }\n}","import { isInteger } from './util'\nimport { Node, NodeProcesser } from './node'\n\nclass TokenType {\n    label = ''\n    conf = {}\n    constructor(label: string, conf = {}) {\n        this.label = label\n        this.conf = conf\n    }\n}\n\nconst letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('')\n\nconst HexDigits = '0123456789ABCDEFabcdef'.split('')\n\nconst types = {\n    backslash: new TokenType('\\\\'),\n    start: new TokenType('^'),\n    end: new TokenType('$'),\n    or: new TokenType('|'),\n    anti: new TokenType('^'),\n    oneMore: new TokenType('*'),\n    add: new TokenType('+'),\n    question: new TokenType('?'),\n    dot: new TokenType('.'),\n    parenL: new TokenType('('),\n    parenR: new TokenType(\")\"),\n    bracketL: new TokenType('['),\n    bracketR: new TokenType(\"]\"),\n    bracesL: new TokenType('{'),\n    bracesR: new TokenType('}'),\n    backspace: new TokenType('[\\\\b]'),\n    range: new TokenType('-'),\n    groupIs: new TokenType('?='),\n    groupElse: new TokenType('?!'),\n    groupAtom: new TokenType('?:'),\n    controlLetter: new TokenType('\\\\c'),\n    hexadecimal: new TokenType('\\\\x'),\n    unicode: new TokenType('\\\\u'),\n    controllerEscape: [\n        new TokenType('\\\\f'),\n        new TokenType('\\\\n'),\n        new TokenType('\\\\r'),\n        new TokenType('\\\\t'),\n        new TokenType('\\\\v'),\n    ],\n    characterClassEscape: [\n        new TokenType('\\\\d'),\n        new TokenType('\\\\D'),\n        new TokenType('\\\\s'),\n        new TokenType('\\\\S'),\n        new TokenType('\\\\w'),\n        new TokenType('\\\\W'),\n    ],\n    assertionEscape: [\n        new TokenType('\\\\b'),\n        new TokenType('\\\\B')\n    ],\n    kws: [\n        new TokenType('\\\\0')\n    ]\n}\n\nconst keyCodes = '\\\\^$|*+?.{['\n\nexport class Parser extends NodeProcesser {\n    input = ''\n    loc = 0\n    pos = 0\n    end = 0\n    groups: Node[] = []\n    node: Node = this.startNode('RegularExpressions')\n    groupCount = 0\n    constructor(str: string) {\n        super()\n        this.input = str\n        this.end = str.length\n        this.parse()\n    }\n    isRangeNode(node: Node) {\n        if (node.type === 'CharacterClassEscape' || node.type === 'CharacterRange' || node.type === 'assertionEscape' || node.type === 'CharacterClassAnti') {\n            return true\n        }\n        return false\n    }\n    parse() {\n        this.pos = 0\n        this.parseStart()\n    }\n    parseStart() {\n        const node = this.node\n        while (this.end > this.pos) {\n            this.next(node);\n        }\n    }\n    parseWord(w: string, node: Node) {\n        switch (w) {\n            case types.start.label:\n                node.children.push(this.startNode('Assertion', w));\n                this.next(node);\n                break;\n            case types.backslash.label:\n                this.processBackSlash(node);\n                this.next(node);\n                break;\n            case types.question.label:\n                if (this.processGreedy(node)) {\n                    break;\n                }\n            case types.add.label:\n            case types.oneMore.label:\n                const nn = this.startNode('QuantifierPrefix', w)\n                this.addQuantifierPrefixNode(node, nn)\n                this.next(node);\n                break;\n            case types.dot.label:\n                node.children.push(this.startNode('Atom', w))\n                this.next(node);\n                break;\n            case types.parenL.label:\n                this.processParenL(node);\n                break;\n            case types.parenR.label:\n                const lastg = this.groups[this.groups.length - 1];\n                if (lastg && !lastg.closed) {\n                    lastg.closed = true\n                    this.groups.splice(-1, 1)\n                    if (lastg.parent) {\n                        this.next(lastg.parent)\n                    }\n                } else {\n                    this.raise(`Unmatched ')'`)\n                }\n                break;\n            case types.bracesL.label:\n                this.processBracesL(node);\n                break;\n            case types.bracesR.label:\n                this.processBracesR(node);\n                break;\n            case types.bracketL.label:\n                this.processBracket(node)\n                break;\n            case types.end.label:\n                node.children.push(this.startNode('Assertion', w))\n                this.next(node);\n                break;\n            case types.or.label:\n                this.processOr(node);\n                break;\n            default:\n                node.children.push(this.startNode('PatternCharacter', w))\n                this.next(node);\n                break;\n        }\n    }\n    // ?\n    processGreedy(node: Node) {\n        const last = node.children[node.children.length - 1]\n        if (last) {\n            if (last.type === 'QuantifierPrefix') {\n                if (last.greedy) {\n                    last.greedy = false\n                    return true\n                } else {\n                    this.raise('Nothing to repeat')\n                }\n            }\n        }\n    }\n    // \\\n    processBackSlash(node: Node, inBracket = false) {\n        while (true) {\n            const w = this.readWord();\n            if (!w) {\n                return\n            }\n            if (w[1] === '\\\\') {\n                node.children.push(this.startNode('PatternCharacter', w[1]))\n                break;\n            }\n            if (w[1] === '^') {\n                node.children.push(this.startNode('PatternCharacter', w[1]))\n                break;\n            }\n            if (keyCodes.indexOf(w[1]) > -1) {\n                if (inBracket) {\n                    node.children.push(this.startNode('PatternCharacter', '\\\\'))\n                }\n                node.children.push(this.startNode('PatternCharacter', w[1]))\n                break\n            }\n            if (this.processEscape(node, w)) {\n                break;\n            }\n            if (!isInteger(w.slice(-1))) {\n                const value = w.substr(1, w.length - 2)\n                if (isInteger(value)) {\n                    node.children.push(this.startNode('DecimalEscape', value))\n                } else {\n                    node.children.push(this.startNode('PatternCharacter', w.substr(1)))\n                }\n                this.pos--;\n                break;\n            }\n            if (this.pos >= this.end) {\n                const value = w.substr(1)\n                if (isInteger(value)) {\n                    node.children.push(this.startNode('DecimalEscape', value))\n                } else {\n                    node.children.push(this.startNode('PatternCharacter', w.substr(1)))\n                }\n                return;\n            }\n        }\n    }\n    // \\\n    processEscape(node: Node, w: string) {\n        // TODO\n        if (w === types.controlLetter.label) {\n            const n = this.startNode('ControlLetter')\n            node.children.push(n)\n            if (this.end <= this.pos) {\n                this.raise('\\\\ at end of pattern')\n                return;\n            }\n            const word = this.eatWord()\n            if (letters.includes(word)) {\n                n.value = word\n            } else {\n                this.parseWord(word, node)\n            }\n            return true\n        }\n        if (w === types.hexadecimal.label) {\n            const n = this.startNode('HexEscapeSequence')\n            node.children.push(n)\n            const word = [this.eatWord(), this.eatWord()];\n            if (HexDigits.includes(word[0]) && HexDigits.includes(word[1])) {\n                n.value = word.join('')\n                return true\n            }\n            this.pos -= 2\n            this.loc = this.pos\n            return true\n        }\n        if (w === types.unicode.label) {\n            const n = this.startNode('UnicodeEscapeSequence')\n            node.children.push(n)\n            const word = [this.eatWord(), this.eatWord(), this.eatWord(), this.eatWord()];\n            if (HexDigits.includes(word[0]) && HexDigits.includes(word[1]) && HexDigits.includes(word[2]) && HexDigits.includes(word[3])) {\n                n.value = w + word.join('')\n                return true\n            }\n            this.pos -= 4\n            this.loc = this.pos\n            return true\n        }\n        const each = (list: TokenType[], type: string) => {\n            for (let i = 0, len = list.length; i < len; i++) {\n                const kws = list[i];\n                if (kws.label === w) {\n                    node.children.push(this.startNode(type, w));\n                    return true\n                }\n            }\n            return false\n        }\n        return each(types.kws, 'CharacterKey') || each(types.controllerEscape, 'ControllerEscape') || each(types.characterClassEscape, 'CharacterClassEscape') || each(types.assertionEscape, 'AssertionEscape')\n    }\n    // [\n    processBracket(node: Node) {\n        const w = this.input.slice(this.loc, this.loc + 4);\n        if (w === types.backspace.label) {\n            const nn = this.startNode('ClassEscape', types.backspace.label)\n            node.children.push(nn)\n            this.loc = this.loc + 4\n            this.pos = this.loc\n            this.next(node)\n            return\n        }\n        const nn = this.startNode('CharacterClass')\n        while (true) {\n            if (this.end <= this.pos) {\n                this.raise('missing /')\n                return;\n            }\n            const word = this.eatWord();\n            if (word === types.bracketR.label) {\n                nn.closed = true;\n                break\n            }\n            switch (word) {\n                case types.anti.label:\n                    if (nn.children.length === 0) {\n                        nn.children.push(this.startNode('CharacterClassAnti'))\n                    } else {\n                        nn.children.push(this.startNode('SourceCharacter', word))\n                    }\n                    break;\n                case types.bracketL.label:\n                    this.raise('missing /')\n                    return;\n                case types.backslash.label:\n                    this.processBackSlash(nn, true);\n                    break;\n                case types.range.label:\n                    const lastChild = nn.children[nn.children.length - 1]\n                    if (!lastChild || this.isRangeNode(lastChild)) {\n                        nn.children.push(this.startNode('SourceCharacter', word))\n                    } else {\n                        const range = this.startNode('CharacterRange', word)\n                        range.children.push(lastChild)\n                        if (this.processRange(range)) {\n                            return;\n                        }\n                        if (range.closed) {\n                            nn.children[nn.children.length - 1] = range\n                        } else {\n                            range.value = types.range.label\n                            const children = range.children\n                            range.children = []\n                            nn.children.push(range, ...children.slice(1))\n                        }\n                    }\n                    break;\n                default:\n                    nn.children.push(this.startNode('SourceCharacter', word))\n                    break;\n            }\n        }\n        node.children.push(nn)\n        this.next(node)\n    }\n\n    processRange(node: Node) {\n        if (this.end <= this.pos) {\n            this.raise('missing /')\n            return;\n        }\n        const word = this.eatWord();\n        switch (word) {\n            case types.bracketR.label:\n                this.finishNode(node, 'SourceCharacter')\n                return;\n            case types.bracketL.label:\n                this.raise('Range out of order in character class')\n                return true;\n            case types.backslash.label:\n                this.processBackSlash(node, true);\n                if (this.isRangeNode(node.children[node.children.length - 1])) {\n                    this.finishNode(node, 'SourceCharacter')\n                    return;\n                }\n                node.closed = true\n                return;\n            case types.range.label:\n                const lastChild = node.children[node.children.length - 1]\n                if (lastChild && lastChild.type === 'CharacterRange' && !lastChild.closed) {\n                    this.raise('Range out of order in character class')\n                    return true;\n                }\n                return;\n            default:\n                node.closed = true\n                node.children.push(this.startNode('SourceCharacter', word))\n                return\n        }\n    }\n    // |\n    processOr(node: Node) {\n        const an = this.startNode('AlternationExpression', types.or.label)\n        const cn1 = this.startNode('ConcatenationExpression')\n        const children = node.children\n        cn1.children = children\n        const cn2 = this.startNode('ConcatenationExpression')\n        an.children.push(cn1, cn2)\n        node.children = [an]\n        this.next(cn2)\n    }\n    raise(e: string) {\n        throw new SyntaxError(e)\n    }\n    // (\n    processParenL(node: Node) {\n        const subNode = this.startNode('SubExpression')\n        this.groups.push(subNode);\n        node.children.push(subNode)\n        if (this.end <= this.pos) {\n            this.raise('Unterminated group')\n            return\n        }\n        subNode.parent = node\n        const w = this.eatWord() + this.eatWord();\n        if (w === types.groupIs.label) {\n            subNode.value = types.groupIs.label\n            this.next(subNode);\n            return\n        }\n        if (w === types.groupElse.label) {\n            subNode.value = types.groupElse.label\n            this.next(subNode);\n            return\n        }\n        if (w === types.groupAtom.label) {\n            subNode.value = types.groupAtom.label\n            this.next(subNode);\n            return;\n        }\n        subNode.groupIndex = this.groupCount\n        this.groupCount = subNode.groupIndex + 1\n        this.pos -= 2\n        this.loc = this.pos;\n        while (!subNode.closed) {\n            if (this.end > this.pos) {\n                this.next(subNode);\n            } else {\n                this.raise('Unterminated group')\n            }\n        }\n    }\n    addQuantifierPrefixNode(node: Node, q: Node) {\n        const last = node.children[node.children.length - 1]\n        if (last) {\n            if (last.type === 'QuantifierPrefix') {\n                this.raise('Nothing to repeat')\n                return\n            }\n            q.children.push(last)\n            node.children[node.children.length - 1] = q\n        } else {\n            if (node.type === 'SubExpression') {\n                this.raise('Invalid group')\n            } else {\n                this.raise('Nothing to repeat')\n            }\n        }\n    }\n    // {\n    processBracesL(node: Node) {\n        const nn = this.startNode('QuantifierPrefix', '{')\n        while (this.end > this.pos && nn.type === 'QuantifierPrefix' && !nn.closed) {\n            this.next(nn)\n        }\n        if (nn.type !== 'QuantifierPrefix' || !nn.closed) {\n            this.finishNode(nn, 'PatternCharacter')\n            nn.value = '{'\n            const children = nn.children\n            nn.children = []\n            node.children.push(nn, ...children)\n        } else {\n            this.addQuantifierPrefixNode(node, nn)\n        }\n        this.next(node)\n    }\n    // }\n    processBracesR(node: Node) {\n        if (node.type === 'QuantifierPrefix') {\n            const hasComma = false\n            let value = ''\n            for (let i = 0, len = node.children.length; i < len; i++) {\n                const item = node.children[i]\n                if (i === 0) {\n                    if (item.type === 'PatternCharacter' && isInteger(item.value)) {\n                        value += item.value;\n                    } else {\n                        this.finishNode(node, 'PatternCharacter')\n                        return;\n                    }\n                } else {\n                    if (!hasComma) {\n                        if (item.type === 'PatternCharacter' && item.value === ',') {\n                            value += item.value;\n                            continue\n                        }\n                        if (item.type === 'PatternCharacter' && isInteger(item.value)) {\n                            value += item.value;\n                            continue\n                        } else {\n                            this.finishNode(node, 'PatternCharacter')\n                            return;\n                        }\n                    }\n                    if (item.type === 'PatternCharacter' && isInteger(item.value)) {\n                        value += item.value;\n                    } else {\n                        this.finishNode(node, 'PatternCharacter')\n                        return;\n                    }\n                }\n            }\n            node.children = []\n            node.closed = true\n            node.value = value\n        } else {\n            node.children.push(this.startNode('PatternCharacter', '}'))\n            this.next(node)\n        }\n    }\n    next(node: Node) {\n        const w = this.eatWord()\n        if (w) {\n            this.parseWord(w, node)\n        }\n    }\n    eatWord() {\n        this.loc = this.pos\n        return this.readWord()\n    }\n    readWord() {\n        this.pos++\n        return this.input.slice(this.loc, this.pos)\n    }\n}\n","import { Node } from './node';\nimport { canonicalize } from './util'\n\nexport interface State {\n    endIndex: number\n    captures: (string | undefined)[]\n    input: string\n    option: {\n        ignoreCase?: boolean\n        multiline?: boolean\n        nodes: Node[]\n    }\n}\n\nexport type Matcher = (x: State, m?: Next) => State | null\n\nexport type Next = (x: State) => State | null\n\nexport const continuation = (x: State) => x\n\nexport const baseMatcher = (m: (x: string) => boolean, anti = false) => {\n    return (state: State, next: Next) => {\n        const { endIndex, input } = state;\n        const code = canonicalize(input[endIndex + 1], state.option.ignoreCase)\n        const i = m(code);\n        const isTrue = anti ? !i : i\n        if (!isTrue) {\n            return null\n        }\n        state.endIndex = endIndex + 1\n        return next(state)\n    }\n}\n\nexport const combineOrMatchers = (nodes: Node[], ctr: (node: Node) => any, anti?: boolean) => {\n    const matchers = nodes.map(ctr)\n    return function (state: State, next: Next = continuation) {\n        const { endIndex } = state\n        if (endIndex >= state.input.length - 1) {\n            return null\n        }\n        for (let i = 0; i < matchers.length; i++) {\n            state.endIndex = endIndex\n            const m = matchers[i]\n            if (anti) {\n                const r = m(state, continuation)\n                if (r) {\n                    return null\n                }\n            } else {\n                const r = m(state, next)\n                if (r) {\n                    return r\n                }\n            }\n        }\n        if (anti) {\n            state.endIndex = endIndex + 1\n            return next(state)\n        }\n        return null\n    }\n}\n\nexport const combineSerialMatchers = (nodes: Node[], ctr: (node: Node) => any, c: Next = continuation) => {\n    const ns = nodes.slice().reverse();\n    let matcher = c\n    for (let i = 0; i < ns.length; i++) {\n        const m = ctr(ns[i])\n        if (i === 0) {\n            matcher = function (x) {\n                return m(x, c)\n            }\n            continue\n        }\n        const n = matcher\n        matcher = function (x) {\n            return m(x, n)\n        }\n    }\n    return function (x: State, next?: Next) {\n        c = next ? next : c\n        return matcher(x)\n    }\n}\n\nexport const characterSetMatcher = (s: string, invert = false) => {\n    return function (state: State, next: Next) {\n        const { endIndex } = state\n        if (endIndex === state.input.length - 1) {\n            return null\n        }\n        const ch = state.input[endIndex + 1]\n        const cc = canonicalize(ch, state.option.ignoreCase)\n        if (invert === false) {\n            if (canonicalize(s, state.option.ignoreCase) !== cc) {\n                return null\n            }\n        } else {\n            if (canonicalize(s, state.option.ignoreCase) === cc) {\n                return null\n            }\n        }\n        const cap = state.captures\n        const y = { ...state, endIndex: endIndex + 1, captures: cap }\n        return next(y)\n    }\n}\n\nexport const repeatMatcher = (m: Matcher, min: number, max: number, greedy: boolean, x: State, c: Next, parenIndex: number, parenCount: number) => {\n    if (max === 0) {\n        return c(x)\n    }\n    const d: Next = function (y: State) {\n        if (min === 0 && y.endIndex === x.endIndex) {\n            return null\n        }\n        const min2 = min === 0 ? 0 : min - 1;\n        const max2 = max === Infinity ? Infinity : max - 1\n        return repeatMatcher(m, min2, max2, greedy, y, c, parenIndex, parenCount)\n    }\n    const cap = [...x.captures]\n    for (let k = parenIndex + 1; k <= parenIndex + parenCount; k++) {\n        cap[k] = undefined\n    }\n    const e = x.endIndex\n    const xr = {\n        ...x,\n        endIndex: e,\n        captures: cap\n    }\n    if (min !== 0) {\n        return m(xr, d)\n    }\n    if (greedy === false) {\n        const z = c(x)\n        if (z) {\n            return z\n        }\n        return m(xr, d)\n    }\n    const z = m(xr, d)\n    if (z) {\n        return z\n    }\n    return c(x)\n}\n","import {\n    isWordChar,\n    isWordChar2, toCharCode, isInteger, isSpace, SPECIAL_CODES, isLineTerminator, evaluateQuantifierValue,\n    getParenCountByAtom,\n    canonicalize,\n    toCode,\n    getParenIndexByNode\n} from './util'\nimport { Node } from './node'\nimport {\n    baseMatcher,\n    combineOrMatchers,\n    combineSerialMatchers,\n    characterSetMatcher,\n    repeatMatcher,\n    State,\n    Next,\n    continuation\n} from './m'\n\nconst beginningMatcher = () => {\n    return function (state: State, next: Next) {\n        const { endIndex } = state;\n        if ((endIndex + 1) !== 0) {\n            if (state.option.multiline) {\n                if (isLineTerminator(state.input[endIndex])) {\n                    return next(state)\n                }\n            }\n            return null\n        }\n        return next(state)\n    }\n}\n\nconst endMatcher = () => {\n    return function (state: State, next: Next) {\n        const { endIndex, input } = state;\n        if (endIndex !== input.length - 1) {\n            if (state.option.multiline) {\n                if (isLineTerminator(state.input[endIndex + 1])) {\n                    return state\n                }\n            }\n            return null\n        }\n        return state\n    }\n}\n\nconst getRangeMatcher = (nodes: Node[]) => {\n    return function (state: State, next: Next) {\n        const { endIndex } = state;\n        const code = canonicalize(state.input[endIndex + 1], state.option.ignoreCase).charCodeAt(0);\n        const [start, end] = nodes;\n        let startValue = start.value || '';\n        let endValue = end.value || '';\n        if (start.type === 'ControllerEscape' || start.type === 'CharacterKey') {\n            startValue = canonicalize(SPECIAL_CODES[startValue], state.option.ignoreCase)\n        }\n        const s = toCharCode(startValue)\n        if (end.type === 'ControllerEscape' || end.type === 'CharacterKey') {\n            endValue = canonicalize(SPECIAL_CODES[endValue], state.option.ignoreCase)\n        }\n        const e = toCharCode(endValue)\n        const result = s <= code && e >= code\n        if (!result) {\n            return null\n        }\n        state.endIndex = endIndex + 1\n        return next(state)\n    }\n}\n\nconst getCharacterClassEscapeMatcher = (pattern: string) => {\n    if (pattern === '\\\\d') {\n        return baseMatcher(isInteger)\n    }\n    if (pattern === '\\\\D') {\n        return baseMatcher(isInteger, true)\n    }\n    if (pattern === '\\\\s') {\n        return baseMatcher(isSpace)\n    }\n    if (pattern === '\\\\S') {\n        return baseMatcher(isSpace, true)\n    }\n    if (pattern === '\\\\w') {\n        return baseMatcher(isWordChar2)\n    }\n    if (pattern === '\\\\W') {\n        return baseMatcher(isWordChar2, true)\n    }\n}\n\nconst getWordCharMatch = (anti = false) => {\n    return function (state: State, next: Next) {\n        const { endIndex: e, input } = state\n        const a = +isWordChar(e, input)\n        const b = +isWordChar(e + 1, input);\n        let result = !!(a ^ b)\n        if (anti) {\n            result = !result\n        }\n        if (!result) {\n            return null\n        }\n        return next(state)\n    }\n}\n\nconst getDecimalEscapeMatcher = (node: Node) => {\n    let value = 0\n    if (node.value) {\n        value = +node.value\n    }\n    return function (state: State, next: Next) {\n        const { endIndex } = state\n        const cap = state.captures[value]\n        if (typeof cap !== 'string') {\n            return next(state)\n        }\n        const s = state.input.slice(endIndex + 1, cap.length + endIndex + 1)\n        if (cap.length !== s.length) {\n            return null\n        }\n        for (let i = 0; i < cap.length; i++) {\n            if (canonicalize(cap[i], state.option.ignoreCase) !== canonicalize(s[i], state.option.ignoreCase)) {\n                return null\n            }\n        }\n        state.endIndex = endIndex + cap.length\n        return next(state)\n    }\n}\n\nconst getCharacterClassMatcher = (node: Node) => {\n    let isAnti = false\n    let children = []\n    if (node.children[0].type === 'CharacterClassAnti') {\n        isAnti = true\n        children = node.children.slice(1)\n    } else {\n        children = node.children\n    }\n    return combineOrMatchers(children, getBaseMatcher, isAnti)\n}\n\n// |\nconst getAlternationExpressionMatcher = (node: Node) => {\n    const m1 = combineSerialMatchers(node.children[0].children, getBaseMatcher)\n    const m2 = combineSerialMatchers(node.children[1].children, getBaseMatcher)\n    return function (state: State, next: Next) {\n        return m1(state, next) || m2(state, next)\n    }\n}\n\n// ()\nconst getSubExpressionMatcher = (node: Node) => {\n    const m = combineSerialMatchers(node.children, getBaseMatcher);\n    if (node.value === '?=') {\n        return function (state: State, next: Next) {\n            const { endIndex } = state\n            const r = m(state)\n            if (!r) {\n                return r\n            }\n            const cap = r.captures\n            const xe = endIndex\n            const z = { ...state, endIndex: xe, captures: cap }\n            return next(z)\n        }\n    }\n    if (node.value === '?!') {\n        return function (state: State, next: Next) {\n            const x = { ...state }\n            const r = m(state, continuation)\n            if (r) {\n                return null\n            }\n            return next(x)\n        }\n    }\n    if (node.value === '?:') {\n        return m\n    }\n    return function (state: State, next: Next) {\n        const xe = state.endIndex;\n        const d = function (y: State) {\n            const cap = [...y.captures];\n            const ye = y.endIndex;\n            const s = state.input.slice(xe + 1, ye + 1)\n            cap[(node.groupIndex || 0) + 1] = s;\n            const z = {\n                ...state,\n                endIndex: ye,\n                captures: cap\n            }\n            return next(z)\n        }\n        return m(state, d)\n    }\n}\n\nconst getQuantifierPrefixMatcher = (node: Node) => {\n    const m = getBaseMatcher(node.children[0])\n    const { min, max, greedy } = evaluateQuantifierValue(node);\n    if (max < min) {\n        throw new SyntaxError('')\n    }\n    const parenCount = getParenCountByAtom(node)\n    return function (state: State, next: Next) {\n        const parenIndex = getParenIndexByNode(node, state.option.nodes)\n        return repeatMatcher(m, min, max, !!greedy, state, next, parenIndex, parenCount)\n    }\n}\n\nconst getClassEscapeMatcher = (node: Node) => {\n    if (node.value === '[\\\\b]') {\n        return characterSetMatcher('\\u0008')\n    }\n}\n\nconst getCharacterKeyMatcher = (node: Node) => {\n    if (node.value === '\\\\0') {\n        return characterSetMatcher(canonicalize(SPECIAL_CODES[node.value]))\n    }\n}\n\n\nconst getBaseMatcher = (node: Node): any => {\n    if (node.type === 'PatternCharacter' || node.type === 'SourceCharacter') {\n        return characterSetMatcher(node.value || '')\n    }\n    if (node.type === 'Atom' && node.value === '.') {\n        return characterSetMatcher(SPECIAL_CODES['\\\\n'], true)\n    }\n    if (node.type === 'Assertion') {\n        if (node.value == '^') {\n            return beginningMatcher()\n        }\n        return endMatcher()\n    }\n    if (node.type === 'HexEscapeSequence') {\n        return characterSetMatcher(toCode(node.value || ''))\n    }\n    if (node.type === 'UnicodeEscapeSequence') {\n        return characterSetMatcher(toCode(node.value || ''))\n    }\n    if (node.type === 'CharacterRange') {\n        return getRangeMatcher(node.children)\n    }\n    if (node.type === 'ControllerEscape') {\n        return characterSetMatcher(SPECIAL_CODES[node.value || ''])\n    }\n    if (node.type === 'CharacterClassEscape') {\n        return getCharacterClassEscapeMatcher(node.value || '')\n    }\n    if (node.type === 'AssertionEscape') {\n        return getWordCharMatch(node.value === '\\\\B')\n    }\n    if (node.type === 'CharacterClass') {\n        return getCharacterClassMatcher(node)\n    }\n    if (node.type === 'AlternationExpression') {\n        return getAlternationExpressionMatcher(node)\n    }\n    if (node.type === 'SubExpression') {\n        return getSubExpressionMatcher(node)\n    }\n    if (node.type === 'QuantifierPrefix') {\n        return getQuantifierPrefixMatcher(node)\n    }\n    if (node.type === 'DecimalEscape') {\n        return getDecimalEscapeMatcher(node)\n    }\n    if (node.type === 'ClassEscape') {\n        return getClassEscapeMatcher(node)\n    }\n    if (node.type === 'CharacterKey') {\n        return getCharacterKeyMatcher(node)\n    }\n}\n\nexport const getMatcher = (node: Node, option: { [k: string]: any } = {}) => {\n    const m = combineSerialMatchers(node.children, getBaseMatcher)\n    return function (input: string, i: number) {\n        return m({ endIndex: i - 1, input, captures: [], option: { ...option, nodes: node.children } })\n    }\n}\n","import { Parser } from './parser';\nimport { getMatcher } from './match';\nimport { State } from './m'\n\nexport default class RegExp2 {\n    source = ''\n    global = false\n    ignoreCase = false\n    multiline = false\n    lastIndex = 0\n    private matcher: (s: string, i: number) => State | null\n    constructor(reg: string, flag?: string) {\n        this.source = reg\n        if (flag) {\n            this.global = flag.indexOf('g') > -1\n            this.ignoreCase = flag.indexOf('i') > -1\n            this.multiline = flag.indexOf('m') > -1\n        }\n        const parse = new Parser(reg)\n        this.matcher = getMatcher(parse.node, {\n            global: this.global,\n            ignoreCase: this.ignoreCase,\n            multiline: this.multiline,\n        })\n    }\n    exec(s: string) {\n        const len = s.length\n        let i = this.lastIndex\n        if (this.global === false) {\n            i = 0\n        }\n        let matchSucceeded = false\n        let r: State | null = null\n        while (matchSucceeded === false) {\n            if (i < 0 || i > len) {\n                this.lastIndex = 0\n                return null\n            }\n            r = this.matcher(s, i)\n            if (r) {\n                matchSucceeded = true\n            } else {\n                i = i + 1\n            }\n        }\n        if (!r) {\n            return null\n        }\n        const e = r.endIndex\n        if (this.global) {\n            this.lastIndex = e\n        }\n        const n = r.captures.length\n        const a: any = []\n        const matchIndex = i\n        a.index = matchIndex\n        a.input = s;\n        a.length = n\n        const matchedSubstr = s.slice(i, e + 1)\n        a[0] = matchedSubstr\n        for (let j = 1; j < n; j++) {\n            a[j] = r.captures[j]\n        }\n        return a\n    }\n}"],"names":[],"mappings":"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"}